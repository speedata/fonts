package type1

import (
	"bufio"
	"io"
	"regexp"
	"strconv"
	"strings"
)

// Char metrics look like this:
// --------------------------
// StartCharMetrics 260
// C 32 ; WX 198 ; N space ; B 0 0 0 0 ;
// C 33 ; WX 314 ; N exclam ; B 132 -7 261 756 ;
// ....
// C -1 ; WX 301 ; N .notdef ; B 0 0 0 0 ;
// EndCharMetrics

// parseCharMetrics starts right behind the newline after StartCharMetrics
func parseCharMetrics(t *Type1, scanner *bufio.Scanner) error {
	wsSemicolonWs := regexp.MustCompile(`\s*;\s*`)
	for scanner.Scan() {
		tokens := wsSemicolonWs.Split(scanner.Text(), -1)
		if tokens[0] == "EndCharMetrics" {
			return nil
		}
		var err error
		var codepoint rune
		char := new(Char)
		char.Kernx = make(map[rune]int)
		for _, k := range tokens {
			v := strings.Split(k, " ")
			switch v[0] {
			case "C":
				char.OrigCodepoint, err = strconv.Atoi(v[1])
				if err != nil {
					return err
				}
			case "WX":
				char.Wx, err = strconv.Atoi(v[1])
				if err != nil {
					return err
				}
			case "N":
				char.Name = v[1]
				codepoint = adobeToUnicodeCodepoint[char.Name]
				char.Codepoint = codepoint
			case "B":
				a, err := strconv.Atoi(v[1])
				if err != nil {
					return err
				}
				b, err := strconv.Atoi(v[2])
				if err != nil {
					return err
				}
				c, err := strconv.Atoi(v[3])
				if err != nil {
					return err
				}
				d, err := strconv.Atoi(v[4])
				if err != nil {
					return err
				}
				char.BBox = []int{a, b, c, d}
			}
		}
		t.CharsName[char.Name] = *char
		if codepoint > 0 {
			t.CharsCodepoint[codepoint] = *char
		}
	}
	return nil
}

// StartKernData
// StartKernPairs 1905
// KPX A T -30
// KPX A U -16
// KPX A Uacute -16

// parseKernData reads from scanner starting right behind StartKernData
func parseKernData(t *Type1, scanner *bufio.Scanner) error {
	for scanner.Scan() {
		tokens := strings.Split(scanner.Text(), " ")
		switch tokens[0] {
		case "StartKernPairs":
			return parseKernPairs(t, scanner)
		}
	}
	return nil
}

// parseKernPairs reads from the scanner starting right behind the newline after StartKernPairs
func parseKernPairs(t *Type1, scanner *bufio.Scanner) error {
	for scanner.Scan() {
		tokens := strings.Split(scanner.Text(), " ")
		switch tokens[0] {
		case "KPX":
			destKernCodepoint := adobeToUnicodeCodepoint[tokens[2]]
			char := t.CharsName[tokens[1]]
			amount, err := strconv.Atoi(tokens[3])
			if err != nil {
				return err
			}
			char.Kernx[destKernCodepoint] = amount
		}
	}
	return nil
}

// AFM data has this structure:
// StartFontMetrics 2.0
// Comment Generated by Fontographer 4.1.4 7.12.2001 at 13:30
// FontName Dolly-Roman
// ...
// EndFontMetrics

// ParseAFM reads the afm (adobe font metric) file from f.
func (t *Type1) ParseAFM(f io.Reader) error {
	var err error
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		tokens := strings.Split(scanner.Text(), " ")
		switch tokens[0] {
		case "FontName":
			t.FontName = tokens[1]
		case "FullName":
			t.FullName = strings.Join(tokens[1:], " ")
		case "FamilyName":
			t.FamilyName = strings.Join(tokens[1:], " ")
		case "Weight":
			t.Weight = tokens[1]
		case "ItalicAngle":
			t.ItalicAngle, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "IsFixedPitch":
			t.IsFixedPitch = tokens[1] == "true"
		case "UnderlinePosition":
			t.UnderlinePosition, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "UnderlineThickness":
			t.UnderlineThickness, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "Version":
			t.Version = tokens[1]
		case "EncodingScheme":
			t.EncodingScheme = tokens[1]
		case "FontBBox":
			a, err := strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
			b, err := strconv.Atoi(tokens[2])
			if err != nil {
				return err
			}
			c, err := strconv.Atoi(tokens[3])
			if err != nil {
				return err
			}
			d, err := strconv.Atoi(tokens[4])
			if err != nil {
				return err
			}
			t.FontBBox = []int{a, b, c, d}
		case "CapHeight":
			t.CapHeight, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "XHeight":
			t.XHeight, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "Descender":
			t.Descender, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "Ascender":
			t.Ascender, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
		case "StartCharMetrics":
			t.NumChars, err = strconv.Atoi(tokens[1])
			if err != nil {
				return err
			}
			t.CharsName = make(map[string]Char, t.NumChars)
			t.CharsCodepoint = make(map[rune]Char, t.NumChars)
			err := parseCharMetrics(t, scanner)
			if err != nil {
				return err
			}
		case "StartKernData":
			err = parseKernData(t, scanner)
			if err != nil {
				return err
			}
		}
	}
	if err := scanner.Err(); err != nil {
		return err
	}
	return nil
}
